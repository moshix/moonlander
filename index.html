<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoonLander with AGC autoland</title>
    <link rel="icon" href="favicon.ico" type="image/png">
    <style>
        body, html {
            margin: 0;
            overflow: hidden;
        }
        #gameCanvas {
            display: block;
            background-color: black;
        }
        #metrics {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
        }
        #legend {
            position: absolute;
            top: 200px;
            left: 10px;
            color: rgb(82, 164, 218);
            font-family: monospace;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="metrics">
        <div>Version..............3.6.8</div>
        <div>Altitude.............<span id="altitude">0</span> m</div>
        <div>Vertical Speed.......<span id="verticalSpeed">0</span> m/s</div>
        <div>Lateral Speed........<span id="lateralSpeed">0</span> m/s</div>
        <div>Acceleration.........<span id="acceleration">0</span> m/s²</div>
        <div>Fuel remaining...... <span id="fuel">500</span> kg</div>
        <div>Fuel Consumption.....<span id="consumption">0</span> kg/s</div>
    </div>
    <div id="legend">
        <div>cursor keys..Impulse steering </div>
        <div>A:...........Autoland</div>
        <div>P............Pause/Unpause</div>
        <div>R............Restart</div>
        <div>M............Mute/Unmute</div>
        <div>T............Asteroid toggle</div>
        <div>______________________________ </div>
        <div>(c) by hotdog studios</div>
    </div>
    <script>

        // Copyright by hot dog studios
        // All rights reserved
        // Moon Lander
        //     a moon lander game with physics as realistics as possible, taken from Apollo 11
        // Development history
        // v 0.1 game logic and animation (time based)
        // v 0.2 load assets and sounds
        // v 0.5 first autolander version...crap
        // v 0.6 AGC logic for finding suitable landing spot
        // v 0.7 attenuate lateral movements and designate landing spot
        // v 0.8 max lateral thrust and vertical speed control
        // v 0.9 find best landing spot among crater landscape
        // v 1.0 landing / crash detection
        // v 1.1 better and smoother navigation in auto-landing, plume control
        // v 1.2 relative lateral thrust in autoland
        // v 1.3 stop acceleration after landing
        // v 1.4 adaptive lateral thrust mgmt
        // v 1.5 game play fixes
        // v 1.6 mobile browsers autoland button
        // v 1.7 Status message after landing
        // v 1.8 Point system
        // v 1.9 clean up stats and crash sound
        // v 2.0 small improvements
        // v 2.1 astronaut Bob !
        // v 2.2 McDonalds is now on the moon! lunarMac special: $519
        // v 2.3 copyright notice
        // v 2.3 cancel animation frame on restart (important!)
        // v 2.4 remove old code
        // v 2.5 asteroid time-based
        // v 2.6 switch to autoland and back to manual with S key
        // v 2.7 randomly play eagle has landed when properly landed
    	// v 2.8 changed to nicer lander svg, and many small fixes
    	// v 2.9 dust particles close to surface
        // v 2.9.4 side thrusters
        // v 2.9.5 change moon size randomly to make Restart more obvious
        // v 3.0   Michael Collins is happy when lander lands correctly
        // v 3.0.4 apply contrary thrust if lateral speed too high
        // v 3.0.5 lateral thrust attenuation
        // v 3.0.6 ullage before staring main engine
        // v 3.0.7 crash sound volume control
        // v 3.0.8-10 various small fixes
        // v 3.1.0-   various bug fixes and enhancements including realistic items
        // v 3.2.0 fix various stuff and code cleanup
        // v 3.3.0 entertainment mode if no key pressed for long time
        // v 3.3.1-9 any steering key during autoland, takes out autopilot mode
        // v 3.4.0 fix abhorrent use of animationFrames thrughout the game. WTH??
        // v 3.5.0 the return of the asteroid
        // v 3.6.0 in autoland, the lander AGC will predict the asteroid trajectory and try to avoid it

        const canvas = document.getElementById('gameCanvas');
        

        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Load images
        const landerImg = new Image();
        landerImg.src = 'lander.png';
        
        const plumeImg = new Image();
        plumeImg.src = 'plume.png';
        
        const craterImg = new Image();
        craterImg.src = 'crater.svg';
        
        const earthImg = new Image();
        earthImg.src = 'earth.png';
        
        const commanderImg = new Image();
        commanderImg.src = 'commander.png';
        
        const planet1Img = new Image();
        planet1Img.src = 'saturn.jpg';
        
        const issImg = new Image();
        issImg.src = 'iss.png';
        
        const asteroidImg = new Image();
        asteroidImg.src = 'asteroid.png'; // Load the asteroid image
        
        const crashedImg = new Image();
        crashedImg.src = 'crashed.svg'; // For crash state
        
        const astronautImg = new Image();
        astronautImg.src = 'astronaut.png';
        
        const mcdonaldImg = new Image();
        mcdonaldImg.src = 'mcdonald.svg';

        const roverImg = new Image();
        roverImg.src = 'rover.svg';

        const leftdustImg = new Image();
        leftdustImg.src = 'leftdust.png';

        const rightdustImg = new Image();
        rightdustImg.src = 'rightdust.png';

        const thrustleftImg = new Image();
        thrustleftImg.src = 'thrustleft.jpg';

        const thrustrightImg = new Image();
        thrustrightImg.src = 'thrustright.jpg';

        const happyImg = new Image();
        happyImg.src = 'happy.png';

        // end of images loading

        // Sounds loading
        const rocketSound = new Audio('rocket.mp3');
        const crashSound = new Audio('crash.mp3');
        const landedSound = new Audio('eaglelanded.mp3')
       

        crashSound.loop = false;
        let isMuted = false;
        let crashPlayed = false;
        let isPaused = false;
        // end sounds loading

        /////////////////////////////////////
        // Global variables
        /////////////////////////////////////
        noAsteroid = false; // if false show asteroid 
        asteroidCollisionAlarm = false;
        topMsg = ""; // for asteroid collision message
        topMsg2 = "";
        sideMsg = "none"; // displays avoidance strategy on the right side of canvas
        plDistance = 300; // distance between planet1Img and earthImg (so they don't overlap)
        userInteraction = false;
        topMsg = "Demo mode - any key to return to game mode";
        demoMode = false; // are we in demo mode?
        keyPressedLongtime = true; // this control entering entertainment mode
        let keyTimeout; // for time of keyPressedLongTime
        keyPressedLongtime2 = true; // this control entering entertainment mode
        let keyTimeout2; // for time of keyPressedLongTime

        altitude = 500; // lander altitude in human readable form
        let earthsize = Math.floor(Math.random() * (80 - 30 + 1)) + 30;
        showBurger = false; // show burger only once in 1 landings
        showhappy = false; // showhappy in command module if good landing
        forceManual = false; // force manual during autoland
        let alTime = 0 ; // for asteroid time animation
        const asteroidSpeed = 40; // pixels per second 
        let animationID; 
        let animationID2;
        let animationID3;
        let animationID4;
        let mcdonaldShown = false; // so we can have motivational msg only when arches shown
        const landerWidth = 50;
        const landerHeight = 50;
        const commanderOrbitSpeed = 0.0001;
        const planet1OrbitSpeed = 0.00001;
        const issOrbitSpeed = 0.00005;
        
        CRATER_COUNT = 5;
        const asteroidIntervalMin = 7000; // Minimum time for asteroid appearances
        const asteroidIntervalMax = 12000; // Maximum time for asteroid appearances

        const GRAVITY = 1.62; // Moon gravity in m/s²
        const APOLLO_THRUST = 45000; // Apollo 11 descent engine thrust in N
        const SIDE_THRUST = 4200; // Apollo lander side thrusters in N
        const LANDER_MASS = 15103; // Mass of Apollo 11 lander in kg
        let landerY, landerX, velocityY, velocityX, accelerationY, accelerationX, fuel, isThrusting, isAutolanding, autolandActivated, earthX, earthY;
        let commanderX = 0;
        let commanderY = 50;
        let planet1X = 0, planet1Y = 800;
        let issX = 1, issY = 550;
        let planet1OrbitRadius = 050;
        let issOrbitRadius = 400;
        let hasLanded = false;
        let isCrashed = false;
        let score = 0;
        let bestLandingSpot = null;
        let preTouchdownSpeeds = { velocityY: 0, velocityX: 0 };
        let landingMode = 'Manual Land'; // at start always in manual

        // Static star positions
        const stars = [];
        const numStars = 80;

        // Crater properties
        const craters = [];


        // Asteroid properties
        let asteroid = null;
        let asteroidStartTime = 0;
        let nextAsteroidInterval = Math.random() * (asteroidIntervalMax - asteroidIntervalMin) + asteroidIntervalMin;

	 
        window.onload = function() {
	         if (isMobile()) {
	            createAutolandButton(); // Show the autoland button
                createRestartButton();
	            CRATER_COUNT = 2; // fewer craters on mobile
	             }
          };


        function initializeGame() {
            resetKeyPressTimer();  // to switch to entertainment mode if no key pressed
            resetKeyPressTimer2(); // to restart game after lanidng if no key pressed 5 sec
           if (animationID || animationID2 || animationID3) {
            
          // console.log("animationID: ",animationID);
            cancelAnimationFrame(animationID);
            cancelAnimationFrame(animationID2);
            cancelAnimationFrame(animationID3);
            cancelAnimationFrame(animationID4);

           }

            if (Math.floor(Math.random() * 6) + 1 === 1) showBurger = true; // show burger for this landing
          
            bestLandingSpot = false;
            showhappy = false; // don't show happy Collins in commander
            landerY = 45;
            landerX = canvas.width / 2 - 25;
            velocityY = 0;
            velocityX = 0.3;
            accelerationY = GRAVITY;
            accelerationX = 0;
            fuel = 528;
            isThrusting = false;
            isThrustLeft = false; // for side thrusters
            isThrustRight = false; // same
            isAutolanding = false;
            autolandActivated = false;
            bestLandingSpot = null;
            preTouchdownSpeeds = { velocityY: 0, velocityX: 0 };
            crashPlayed = false;
            hasLanded = false;
            isCrashed = false;
            score = 0;
            isPaused = false;
            landingMode = 'Manual Land';
            nextAsteroidInterval = Math.random() * (asteroidIntervalMax - asteroidIntervalMin) + asteroidIntervalMin;
            asteroidStartTime = 0;
            asteroid = null;
            forceManual = false; // reset foce manual
            createAsteroid();

            // Random position for earth
            earthsize = Math.floor(Math.random() * (80 - 30 + 1)) + 30;
            earthX = Math.random() * (canvas.width - 100);
            earthY = Math.random() * (canvas.height / 2);

            randomPlanet1(); // put saturn (planet1Img) on canvas without overlapping earthImg


            // Redraw craters and stars
            craters.length = 0;
            generateCraters();

            // Allow stars to be drawn across the entire canvas
            stars.length = 0;
            for (let i = 0; i < numStars; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height; // Allow stars to cover entire height
                const size = Math.random() * 2;
                stars.push({ x, y, size });
            }
            cancelAnimationFrame(animationID2);
            animationID2 = requestAnimationFrame(gameLoop);


        }

        function drawMcdonald(landerX, landerY, landerWidth, landerHeight) {
           
            const astronautWidth = landerWidth / 3; // Astronaut width is 1/3 of lander width
            const astronautHeight = landerHeight / 3; // Astronaut height is 1/3 of lander height
            // Initial position: to the right of the lander
            let astronautX = landerX + landerWidth + 10 + 20; // after astronaut
            let astronautY = landerY + landerHeight - astronautHeight; // Align bottom with lander
            let mcdonaldX = astronautX;
        
            // Check if the right side position is safe
            if (astronautX + astronautWidth <= canvas.width && isSafeLanding(astronautX, astronautWidth)) {
                mcdonaldShown = true;
                // Right side is safe, proceed to draw
            } else {
                // Right side is not safe, try left side
                mcdonaldX = landerX - astronautWidth - 40;
        
                // Check if the left side position is safe
                if (astronautX >= 0 && isSafeLanding(astronautX, astronautWidth)) {
                    mcdonaldShown = true;
                    // Left side is safe, proceed to draw
                } else {
                     mcdonaldShown = false;

                    return; // Exit if no valid position is found
                }
            }
        
            // Draw the astronaut SVG at the calculated position
            //ctx.drawImage(astronautImage, astronautX, astronautY, astronautWidth, astronautHeight);
            ctx.drawImage(mcdonaldImg, mcdonaldX + 5, astronautY-38, astronautWidth * 3.5, astronautHeight * 7);
            ctx.drawImage(roverImg, mcdonaldX + 94, astronautY-3 , astronautWidth *2.2, astronautHeight * 2.2);
        }

        function drawAstronaut(landerX, landerY, landerWidth, landerHeight) {
            const astronautWidth = landerWidth / 2; // Astronaut width is 1/3 of lander width
            const astronautHeight = landerHeight / 2; // Astronaut height is 1/3 of lander height
        
            // Initial position: to the right of the lander
            let astronautX = landerX + landerWidth + 10;
            let astronautY = landerY + landerHeight - astronautHeight +16; // Align bottom with lander
        
            // Check if the right side position is safe
            if (astronautX + astronautWidth <= canvas.width && isSafeLanding(astronautX, astronautWidth)) {
                // Right side is safe, proceed to draw
            } else {
                // Right side is not safe, try left side
                astronautX = landerX - astronautWidth - 10;
        
                // Check if the left side position is safe
                if (astronautX >= 0 && isSafeLanding(astronautX, astronautWidth)) {
                    // Left side is safe, proceed to draw
                } else {
                    
                    return; // Exit if no valid position is found
                }
            }
        
            // Draw the astronaut at the calculated position
            //ctx.drawImage(astronautImage, astronautX, astronautY, astronautWidth, astronautHeight);
            ctx.drawImage(astronautImg, astronautX, astronautY, astronautWidth*1.3, astronautHeight*1.3);
        }


            function resetKeyPressTimer2() {
                clearTimeout(keyTimeout2); // Clear any existing timeout
                keyTimeout2 = setTimeout(() => {
                CRATER_COUNT = 5; // less craters in demo mode for more fun watching
                topMsg = "Demo mode - any key to return to game mode";
                demoMode = true;
                isMuted = true;
                initializeGame(); // Restart the game after 5 seconds of no key press
                    
                }, 21000);
        }
        function drawStatusLine() {
          
            ctx.font = "34px Arial"; // Set font size and type
            oldVelocityXF = Number(oldVelocityX).toFixed(2);
            oldVelocityYF = Number(oldVelocityY).toFixed(2);

            if (hasLanded && !isCrashed) {
                //clearTimeout(keyTimeout2);
		        landerY = canvas.height -67; // put lander on surface
                showhappy = true;
                points = fuel - ( (oldVelocityX * 200) + (oldVelocityY * 200));
                pointsF = Number(points).toFixed(0); // make integer
                ctx.fillStyle = "green"; // Green color for successful landing
                ctx.textAlign = "center";
                ctx.fillText("Landed", canvas.width /2, 80);
                ctx.font = "20px Arial"; // for stats smaller font
                message = "Lateral v = " + oldVelocityXF.toString() + "  -  Vertical v = " + oldVelocityYF.toString()
                ctx.textAlign = "center";
                ctx.fillText(message, canvas.width /2, 100);
				drawAstronaut(landerX, landerY, landerWidth, landerHeight);
				drawMcdonald(landerX, landerY, landerWidth, landerHeight);

                // points system
                ctx.fillStyle = "orange"; // Green color for successful landing
                ctx.textAlign = "center";
                ctx.font = "25px Arial"; // for stats smaller font
                message = "Points:  " + pointsF;
                ctx.textAlign = "center";
                ctx.fillText(message, canvas.width /2, 135);
                // Resume to restart message
                ctx.fillStyle = "white"; // Green color for successful landing
                ctx.textAlign = "center";
                ctx.font = "28px Arial"; // for stats smaller font
                ctx.fillText("Press R to restart", canvas.width /2, 170);
                ctx.fillStyle = "cyan"; // Green color for successful landing
                ctx.textAlign = "center";
                ctx.font = "18px Arial"; // for stats smaller font
                ctx.fillText("Game restarts into demo mode if no key pressed", canvas.width /2, 220);


                // motivational message
                ctx.fillStyle = "#FFCC00"; // Green color for successful landing
                ctx.textAlign = "center";
                ctx.font = "37px Arial"; // for stats smaller font
                if (mcdonaldShown) {
                  if (showBurger && !isMobile) ctx.fillText("Taste the new lunar burger now!", canvas.width /2, 280);
                  landingMode = 'Landed';
		        }
                mcdonaldShown = false; // reset immediately
                

            } else if (isCrashed) {
                //clearTimeout(keyTimeout2);
                ctx.fillStyle = "red"; // Red color for crash
                ctx.textAlign = "center";
                ctx.fillText("Crashed", canvas.width /2 , 80);
                ctx.font = "20px Arial"; // for stats smaller font
                message = "Lateral v = " + oldVelocityXF.toString() + "  -  Vertical v = " + oldVelocityYF.toString()
                ctx.textAlign = "center";
                ctx.fillText(message, canvas.width /2, 100);
                // points system
                ctx.fillStyle = "orange"; // Green color for successful landing
                ctx.textAlign = "center";
                ctx.font = "25px Arial"; // for stats smaller font
                message = "Points: 0";
                ctx.textAlign = "center";
                ctx.fillText(message, canvas.width /2, 135);
                // Resume to restart message
                ctx.fillStyle = "white"; // Green color for successful landing
                ctx.textAlign = "center";
                ctx.font = "28px Arial"; // for stats smaller font
                ctx.fillText("Press R to restart", canvas.width /2, 170);
                ctx.fillStyle = "cyan"; // Green color for successful landing
                ctx.textAlign = "center";
                ctx.font = "18px Arial"; // for stats smaller font
                ctx.fillText("Game restarts into demo mode if no key pressed", canvas.width /2, 220);
		        landingMode = '';    
            }
           
        }


        // Asteroid logic
        function createAsteroid() {
        asteroid = null;
        const direction = Math.random() < 0.5 ? 'left' : 'right'; // Asteroid comes from left or right
        const startY = Math.random() * (canvas.height - 220); // Random starting altitude within the canvas

        asteroid = {
        x: direction === 'left' ? 0 : canvas.width, // Start from the left or right
        y: startY,
        speedX: direction === 'left' ? 2 : -2, // Move diagonally
        speedY: 0.6, // Always moves downward
        width: 50,
        height: 50,
        direction
         };
        }


      function drawAsteroid(timestamp) {
          if (!alTime) alTime = timestamp;
          const adeltaTime = (timestamp - alTime) / 1300; // convert to seconds
          alTime = timestamp;
      
          if (asteroid && !noAsteroid) {
              ctx.drawImage(asteroidImg, asteroid.x, asteroid.y, asteroid.width*1.3, asteroid.height*1.3);
      
              // Move the asteroid based on time elapsed
              asteroid.x += asteroid.speedX * asteroidSpeed * adeltaTime;
              asteroid.y += asteroid.speedY * asteroidSpeed * adeltaTime;
      
              // Check if the asteroid goes off-screen
              if (asteroid.x < -asteroid.width || asteroid.x > canvas.width || asteroid.y > canvas.height) {
                  nextAsteroidInterval = Math.random() * (asteroidIntervalMax - asteroidIntervalMin) + asteroidIntervalMin;
                  // Optionally reset asteroid position here
              }
      
              // Check for collision with the lander
              if (
                  asteroid.x < landerX + 50 &&
                  asteroid.x + asteroid.width > landerX &&
                  asteroid.y < landerY + 50 &&
                  asteroid.y + asteroid.height > landerY &&
                  landerY >> 100
              ) {
                  isCrashed = true;
              }
          }
        // Request the next animation frame, passing the current timestamp
        cancelAnimationFrame(animationID3);
        animationID3 = requestAnimationFrame(drawAsteroid);
   }


   function avoidAsteroid() {
    // Define the prediction time and granularity
    const predictionTime = 2.5; // Predict 3 seconds into the future
    const timeStep = 0.05; // Smaller time steps for precise prediction

    let futureAsteroidX = asteroid.x;
    let futureAsteroidY = asteroid.y;
    let futureLanderX = landerX;
    let futureLanderY = landerY;

    // Simulate asteroid and lander positions over the prediction time
    for (let t = 0; t < predictionTime; t += timeStep) {
        // Predict asteroid's future position
        futureAsteroidX += asteroid.speedX * asteroidSpeed * timeStep;
        futureAsteroidY += asteroid.speedY * asteroidSpeed * timeStep;

        // Predict lander's future position based on its velocity and acceleration
        futureLanderX += velocityX * timeStep;
        futureLanderY += velocityY * timeStep + (0.5 * GRAVITY * timeStep * timeStep); // Include gravity effect

        // Break early if the asteroid goes off-screen
        if (futureAsteroidX < -asteroid.width || futureAsteroidX > canvas.width || futureAsteroidY > canvas.height) {
            break;
        }

        // Check for a future collision with the lander
        const willCollideHorizontally =
            futureAsteroidX < futureLanderX + landerWidth+90 &&
            futureAsteroidX + asteroid.width > futureLanderX;
        const willCollideVertically =
            futureAsteroidY < futureLanderY + landerHeight+90 &&
            futureAsteroidY + asteroid.height > futureLanderY;
        
        if (willCollideHorizontally && willCollideVertically && !noAsteroid) {
            asteroidCollisionAlarm = true; // mark we are in collision avoidance mode
             topMsg2 = "Asteroid collision detected. Calculating avoidance trajectory";
            // Apply corrective thrust to avoid collision
            if (futureAsteroidX > futureLanderX) {
                // Asteroid predicted to be on the right, move lander to the right
                sideMsg = "Right -0.5m/s";
                velocityX = velocityX /4; isThrusting = true;
                accelerationX = 0.5; // Strong left thrust
            } else {
                // Asteroid predicted to be on the left, move lander to the right
                sideMsg = "Left 0.5m/s";
                velocityX = velocityX / 4; isThrusting = true;
                accelerationX = -0.5; // Strong right thrust
            }

            if (futureAsteroidY < futureLanderY && landerY > canvas.height - 200) {
                // Asteroid predicted to be above, move lander downward (if safe)
                sideMsg = "Down 0.01m/s";
                isThrusting = true;
                accelerationY = 0.01; velocityY = 0.6;
            } else {
                // Asteroid predicted to be below, move lander upward
                velocityY = -0.1
                sideMsg = "Up 3.1m/s"; isThrusting = true;
                accelerationY = -3.1; velocityY = -0.5;
            }

            return; // Exit once corrective action is applied
        }
    }
    topMsg2 = ""; // no collision trajectory detected\
    asteroidCollisionAlarm = false; // out of collision danger
 
}


        function generateCraters() {
            for (let i = 0; i < CRATER_COUNT; i++) {
                const width = Math.random() * 50 + 50;
                const height = width * 2; // 100% taller
                const x = Math.random() * canvas.width;
                const y = canvas.height - height / 2;
                craters.push({x, y, width, height});
            }
        }

        // is the lander lander on a crater??
        function isSafeLanding(xPos, width) {
            for (let i = 0; i < craters.length; i++) {
                const crater = craters[i];
                if (xPos + width > crater.x && xPos < crater.x + crater.width) {
                    return false;
                }
            }
            return true;
        }

        function drawCraters() {
            craters.forEach(crater => {
                ctx.drawImage(craterImg, crater.x, crater.y, crater.width, crater.height);
            });
        }

        function drawStars() {
            ctx.fillStyle = 'white';
            for (let i = 0; i < stars.length; i++) {
                const { x, y, size } = stars[i];
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawLander() {
            if (isMuted) {
                ctx.fillStyle = "white"; 
                ctx.textAlign = "right";
                ctx.fillText("Muted", canvas.width -47, 80);
                ctx.font = "19px Arial"; 
             }

            if (isCrashed) {
                ctx.drawImage(crashedImg, landerX, landerY, 40, 40);
            } else {
                ctx.drawImage(landerImg, landerX, landerY, 75, 75);
            }

            if (isThrustLeft && !isCrashed && !hasLanded) {
                    ctx.drawImage(thrustleftImg, landerX - 7, landerY +20, 24,24);
                }

                if (isThrustRight) {
                    ctx.drawImage(thrustrightImg, landerX +57 , landerY + 20, 24, 24);

                }

            if (isThrusting && fuel > 0 && !isCrashed && !hasLanded) {
                ctx.drawImage(plumeImg, landerX -26, landerY + 19, 130, 150);
                        
                drawDust();
               
 
            }
        }

        function drawDust() {
            // show dust if approaching moon surface
            if (landerY > canvas.height - 300) {
               
                ctx.drawImage(leftdustImg, landerX - 64,
                    //canvas.height - 34 - ((canvas.height - landerY) / canvas.height) * (130 - 34),
                    canvas.height - Math.max(30, Math.min(90, 90 - ((canvas.height - landerY) * 0.2))),
                    Math.max(40, Math.min(140, 140 - ((canvas.height - landerY) * 0.2))),
                    Math.max(40, Math.min(140, 140 - ((canvas.height - landerY) * 0.2)))); // scalecd with hight
                ctx.drawImage(rightdustImg, landerX + 64,
                    //Math.max(canvas.height - 50, canvas.height - 34 - ((canvas.height - landerY) * 0.1)), // 
                    canvas.height - Math.max(30, Math.min(90, 90 - ((canvas.height - landerY) * 0.2))),
                    Math.max(40, Math.min(140, 140 - ((canvas.height - landerY) * 0.2))),
                    Math.max(40, Math.min(140, 140 - ((canvas.height - landerY) * 0.2)))); // scalecd with hight
            }  
        }


        function drawEarth() {
            ctx.drawImage(earthImg, earthX, earthY, earthsize, earthsize);
        }


        function drawCommanderModule(currentTime) {
            const orbitRadius = canvas.width / 3;
            commanderX = canvas.width / 2 + Math.cos(currentTime * commanderOrbitSpeed) * orbitRadius;
            commanderY = 50 + Math.sin(currentTime * commanderOrbitSpeed) * 30;
            ctx.drawImage(commanderImg, commanderX, commanderY, 85, 50);
            if (showhappy) {
               // ctx.drawImage(happyImg, commanderX+15, commanderY +9, 37,37);
            }
        }

  //      function drawPlanet1() {
  //          // Random position for Saturn
  //          planet1X = Math.random() * (canvas.width - 100);
  //          planet1Y = Math.random() * (canvas.height / 2);
//
 //           ctx.drawImage(planet1Img, planet1X, planet1Y, 60, 60);
  //      }

        function randomPlanet1() {

                 // Generate random positions for planet1
                plDistance = 100; // force while loop 
                while (plDistance < 200){
                planet1X = Math.random() * (canvas.width - 100);
                planet1Y = Math.random() * (canvas.height / 2);

                // Calculate the distance from planet1 to Earth
                plDistance = Math.sqrt(Math.pow(planet1X - earthX, 2) + Math.pow(planet1Y - earthY, 2));

                 }

        }

        function drawPlanet1() {
            // Draw the planet
            ctx.drawImage(planet1Img, planet1X, planet1Y, 60, 60);
        }



        function drawISS(currentTime) {
            const orbitRadius = issOrbitRadius;
            issX = canvas.width / 4 + Math.cos(-currentTime * issOrbitSpeed) * orbitRadius;
            issY = 450 + Math.sin(-currentTime * issOrbitSpeed) * 20;
            ctx.drawImage(issImg, issX - 350, issY-250, 80, 80);
        }


        function autoland() {
            autolandActivated = true;



            if (forceManual) {

                landingMode = 'Switched to manual';
                return;
            }
            // calculate the largest flat landing area
            let largestFlatAreaStart = 0;
            let largestFlatWidth = 0;
            let currentFlatStart = null;
            let currentFlatWidth = 0;


            for (let x = 0; x < canvas.width; x += 5) {
                if (isSafeLanding(x, 50)) { // Safe landing spot
                    if (currentFlatStart === null) {
                        currentFlatStart = x; // Start new flat area
                    }
                    currentFlatWidth += 5; // Expand flat area
                } else { // End of flat area
                    if (currentFlatWidth > largestFlatWidth) {
                        largestFlatAreaStart = currentFlatStart;
                        largestFlatWidth = currentFlatWidth;
                    }
                    currentFlatStart = null;
                    currentFlatWidth = 0;
                }
            }

            if (currentFlatWidth > largestFlatWidth) { // Handle last flat area
                largestFlatAreaStart = currentFlatStart;
                largestFlatWidth = currentFlatWidth;
            }

            bestLandingSpot = largestFlatAreaStart + largestFlatWidth / 2; // Center of the largest flat area

            // adjust indicated P program according to height
            if (altitude > 600) landingMode = "Autoland P63";
            if (altitude > 450 && altitude.toFixed(2) < 280) landingMode = "Autoland P64";
            if (altitude < 270) landingMode = "Autoland P65";


            // Adjust lateral thrust smoothly toward best landing spot
            const lateralDistance = bestLandingSpot - landerX;
            let maxLateralThrust = 0.20; // Cap the lateral thrust
            let heightFraction = landerY / (canvas.height - 50); // landerY as a fraction of canvas
            const inverseHeightFactor = 1 - heightFraction; // Inverse fraction: smaller as lander approaches ground

            // Cap lateral speed to x m/sec
            const maxLateralSpeed = 0.35; // Maximum allowed lateral speed



            // this applies less thrust as the lander gets closer to the moon surface
            let scaledLateralThrust = Math.min(maxLateralThrust, (lateralDistance + 3) / (canvas.width * inverseHeightFactor + 1)); // Avoid division by zero

            // try to avoid asteroid!
            avoidAsteroid();
            if (!asteroidCollisionAlarm) {
                if (Math.abs(lateralDistance) > 1) {
                    scaledLateralThrust = scaledLateralThrust * Math.sign(lateralDistance);
                    if (Math.abs(velocityX) < maxLateralSpeed) {
                        accelerationX = scaledLateralThrust * Math.sign(lateralDistance);
                    } else {
                        accelerationX = (scaledLateralThrust * Math.sign(lateralDistance)) / 3; // cut down thurst by 2/3

                    }

                    if (velocityX > 0.62) { // contrary thrust if not too close to grnd

                        accelerationX = -scaledLateralThrust * 1.33;
                    }

                    if (velocityX < -0.62) { // contrary thrust if not too close to grnd
                        accelerationX = scaledLateralThrust * 1.33;
                    }


                    // Set thrust direction based on acceleration
                    if (accelerationX < 0) {
                        isThrustLeft = false;;
                        isThrustRight = true;;
                    } else if (accelerationX > 0) {
                        isThrustLeft = true;
                        isThrustRight = false;;
                    } else {
                        isThrustLeft = false;
                        isThrustRight = false;
                    }

                } else {
                    accelerationX = 0; // Stop lateral movement when close enough
                    isThrustLeft = false;
                    isThrustRight = false;
                }




                // Apply Proportional Vertical Thrust**
                if (landerY < canvas.height - 60) { // Above ground
                    if (velocityY > 0.37) { // Only apply thrust if the lander is descending (velocityY > 0)
                        // Apply upward thrust if descending too fast
                        if (velocityY > 0.8) {
                            accelerationY = -0.8 * GRAVITY; // Strong upward thrust to slow descent
                            isThrusting = true;
                        } else if (velocityY < 0.5) {
                            accelerationY = -0.3 * GRAVITY;
                            isThrusting = true;
                        } else if (velocityY < 0.2) {
                            // Minimal thrust for a gentle landing
                            accelerationY = -0.1 * GRAVITY;
                            isThrusting = true;
                        } else {
                            accelerationY = -0.00 * GRAVITY; // Let gravity pull the lander down gently
                            isThrusting = false;
                        }
                    } else {
                        // No upward thrust if the lander is already moving upwards (velocityY <= 0)
                        accelerationY = 0 * GRAVITY; // Only gravity is applied to pull it down
                        isThrusting = false;
                    }
                } else {

                    if (landerY >= canvas.height - 69) { // On the ground
                        accelerationY = 0;
                        oldVelocityX = velocityX;
                        accelerationX = 0;
                        isThrusting = false;
                        isThrustLeft = false;
                        isThrustRight = false;
                        hasTouchedDown = true
                        //clearTimeout(keyTimeout2); // clear timeout for demo mode
                        checkLanding(true); // Check if landing is successful
                    }
                }
            }

    }

        
        function resetKeyPressTimer() {
            clearTimeout(keyTimeout); // Clear any existing timeout
            keyPressedLongtime = true; // A key has been pressed
            keyTimeout = setTimeout(() => {
                keyPressedLongtime = false; // Set to false after 5 seconds of no key presses
                    
                if (!isCrashed || !hasLanded) {
                    topMsg = "Autopilot engaged - cursor keys to land manually";
                } else {
                    topMsg = "";
                }
                    
                demoMode = true; // display demomode text
                autolandActivated = true;
                
            }, 1100);
        }

        function checkLanding(hasTouchedDown) {
            if (hasTouchedDown) {
                // Check if lander is landing within safe speed limits
                const safeVerticalSpeed = 1.8; // Safe vertical landing speed (in meters/sec)
                const safeLateralSpeed = 1.3;  // Safe lateral landing speed (in meters/sec)

                // Check vertical speed
                if (Math.abs(velocityY) > safeVerticalSpeed) {
                isCrashed = true;
                isThrusting = false;
                isThrustLeft = false;
                isThrustRight = false;
                bestLandingSpot = false;
                drawLander();
                if (!isMuted) {
                    crashSound.volume = 0.2;
                    crashSound.play();
                  }
               
                return;
                }

                // Check lateral speed
                if (Math.abs(velocityX) > safeLateralSpeed) {
                    accelerationX = 0;
                    isCrashed = true;
                    isThrusting = false;
                    bestLandingSpot = false;
                    drawLander();
                    if (!isMuted) crashSound.play();
                    return;
                }

                // Check if it's landing on a safe flat surface
                if (!isSafeLanding(landerX, landerWidth)) {
                    isCrashed = true;
                    accelerationX = 0;
                    bestLandingSpot = false;
                    isThrusting = false;
                    drawLander();
                    if (!noAsteroid) drawAsteroid();
                    if (!isMuted) crashSound.play();
                    return;
                }

                // If all conditions are met, it's a safe landing
                isCrashed = false;
                isThrusting = false;
                isThrustLeft = false;
                isThrustRight = false;
                bestLandingSpot = false;
                accelerationX = 0;
                // play eagle has landed sound
                if (!isMuted) {
                if (Math.floor(Math.random() * 6) + 1 === 1) landedSound.play();  
                }
            }
        }

          // draw a crossmark where the lander has decided to land
          function drawLandingCross() {
              if (bestLandingSpot !== null && !hasLanded) { // Ensure the landing spot is chosen
                  const crossSize = 20; // Size of the cross
                  const crossX = bestLandingSpot; // The x-position of the landing spot
                  const crossY = canvas.height - 35; // Near the ground level of the moon

                  // Draw vertical line of the cross
                  ctx.strokeStyle = 'red';
                  ctx.lineWidth = 3;
                  ctx.beginPath();
                  ctx.moveTo(crossX, crossY - crossSize);
                  ctx.lineTo(crossX, crossY + crossSize);
                  ctx.stroke();

                  // Draw horizontal line of the cross
                  ctx.beginPath();
                  ctx.moveTo(crossX - crossSize, crossY);
                  ctx.lineTo(crossX + crossSize, crossY);
                  ctx.stroke();
              }
          }

        function isMobile() {
            // is it a mobile client?
            return /Android|iPhone|iPad|iPod|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function createAutolandButton() {
            const button = document.createElement("button");
            button.innerHTML = "autoland";
            button.style.position = "absolute";
            button.style.top = "130px";
            button.style.right = "5px";
            button.style.zIndex = "10"; // Ensure it appears above the canvas
            button.style.padding = "10px 20px";
            button.style.fontSize = "18px";

            // Add event listener to trigger autoland when clicked
            button.addEventListener("click", () => {
                autoland();
            });

            // Append the button to the body
            document.body.appendChild(button);
        }
        function createRestartButton() {
            const button = document.createElement("button");
            button.innerHTML = "restart";
            button.style.position = "absolute";
            button.style.top = "170px";
            button.style.right = "5px";
            button.style.zIndex = "10"; // Ensure it appears above the canvas
            button.style.padding = "10px 20px";
            button.style.fontSize = "18px";

            // Add event listener to trigger autoland when clicked
            button.addEventListener("click", () => {
                initializeGame();
            });

            // Append the button to the body
            document.body.appendChild(button);
        }



        function displayMode() {
            ctx.fillStyle = 'white';
            ctx.font = '18px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(landingMode, canvas.width - 20, 40);
            if (demoMode){
                ctx.fillStyle = "crimson";
                ctx.textAlign = "center";
                ctx.font = "23px Arial";
                ctx.fillText(topMsg, canvas.width /2, 20);
                ctx.fillStyle = "Yellow";
                ctx.fillText(topMsg2,canvas.width /2, 40 )
                ctx.font = "16px Arial";
                ctx.fillStyle = "white";
                ctx.textAlign = 'right';
               // ctx.fillText(sideMsg, canvas.width -40,140)
            }
        }

        let lastTime = 0;
        
        function gameLoop(currentTime) {
            if (!userInteraction) {isMuted = true;}
    		// Calculate the altitude (distance from the bottom of the canvas)
            altitude = canvas.height - landerY - 55; // Lander height from the bottom
            
           sideMsg = "none;"
            // Update the stats in the HTML
            document.getElementById('altitude').textContent = altitude.toFixed(2);
            document.getElementById('verticalSpeed').textContent = velocityY.toFixed(2);
            document.getElementById('lateralSpeed').textContent = velocityX.toFixed(2);
            document.getElementById('acceleration').textContent = (Math.abs(accelerationY) + Math.abs(accelerationX)).toFixed(2);
            document.getElementById('fuel').textContent = fuel.toFixed(2);
            document.getElementById('consumption').textContent = isThrusting ? (5).toFixed(2) : (0).toFixed(2); // Fuel consumption during thrust
           // document.getElementById('sideMsg');
            if (!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            if (isPaused) {
                ctx.fillStyle = 'white';
                ctx.font = '24px monospace';
                ctx.fillText('Paused', canvas.width / 2 - 50, canvas.height / 2);
                cancelAnimationFrame(animationID4);
                animationID4 = requestAnimationFrame(gameLoop); // Continue the loop but skip updates
                return;
            }

            if (!hasLanded && !isCrashed) {
                if (autolandActivated) {

                    autoland();

                }
                
                if (isThrusting && fuel > 0) {
                    fuel -= 5 * deltaTime;
                    // drawDust();
                    if (!isMuted) rocketSound.play();
               
                    if (fuel < 0) fuel = 0;
                } else {
                    accelerationY = GRAVITY;
                    rocketSound.pause();
                }

                if (accelerationX !== 0 && fuel > 0) {
                    velocityX += accelerationX * deltaTime;
                    fuel -= 3 * deltaTime;
                }

                velocityY += accelerationY * deltaTime;
                landerY += velocityY * deltaTime * 100;
                landerX += velocityX * deltaTime * 100;

                oldVelocityY =  velocityY; // to print stats at the end
                oldVelocityX =  velocityX; // to print stats at the end

                if (landerY >= canvas.height - 54) {
                    landerY = canvas.height - 50;
                    oldVelocityY =  velocityY; 
                    oldVelocityX =  velocityX;
                    hasLanded = true;
                    topMsg = "";
                    checkLanding(true);
                }

                if (landerX < 0) landerX = 0;
                if (landerX > canvas.width - 50) landerX = canvas.width - 50;
            }


            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!hasLanded) {
                drawLandingCross(); // Draw the red cross after clearing
            }
            drawStars();  // Stars drawn first, covering the whole canvas
            drawEarth();
            drawPlanet1();
            drawLander(currentTime);
            drawCommanderModule(currentTime);
            drawISS(currentTime);
            drawCraters();  // Craters drawn last
            drawAsteroid(currentTime);

            displayMode();

			drawStatusLine();
            cancelAnimationFrame(animationID);
            animationID = requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => {
            userInteraction = true;
            resetKeyPressTimer(); // Reset the timer on every key press
            resetKeyPressTimer2(); // reset time for after landing/crashing
            demoMode = false;
            switch (e.code) {
                case 'Space':
                    if (!hasLanded && !isCrashed) isThrusting = true;
                    break;
                case 'ArrowLeft':
                    if (!hasLanded && !isCrashed) {
                        forceManual = !forceManual;
                        autolandActivated = false;
                        accelerationX = -SIDE_THRUST / LANDER_MASS;
                        isThrustLeft = false;
                        isThrustRight = true;
                        isThrusting = false;
                    }
                    break;
                case 'ArrowRight':
                    if (!hasLanded && !isCrashed) {
                        forceManual = !forceManual;
                        autolandActivated = false;
                        accelerationX = SIDE_THRUST / LANDER_MASS;
                        isThrustRight = false;
                        isThrustLeft = true;
                        isThrusting = false;
                    }
                    break;
                case 'ArrowUp':
                    if (!hasLanded && !isCrashed) {
                        forceManual = !forceManual;
                        autolandActivated = false;
                        isThrusting = true;
                        isThrustLeft = false;
                        isThrustRight = false; // if only going up no side thrusters
                        accelerationY = -APOLLO_THRUST / LANDER_MASS;
                    }
                    break;
                case 'KeyA':
                    if (!hasLanded && !isCrashed) {
                        autolandActivated = true;
                        landingMode = 'Autoland Mode';
                        forceManual = false;
                    }
                    break;
                case 'KeyR':
                    initializeGame();
                    break;
                case 'KeyM':
                    isMuted = !isMuted;
                    //landingMode = isMuted ? 'Muted' : 'Manual Land';
                    rocketSound.muted = isMuted;
                    crashSound.muted = isMuted;
                    break;
                case 'KeyT':
                    noAsteroid = !noAsteroid;
                    break;    
                case 'KeyP':
                    isPaused = !isPaused;
                    if (isPaused) {
                        landingMode = 'Paused';
                    } else {
                        landingMode = autolandActivated ? 'Autoland Mode' : 'Manual Land';
                       //requestAnimationFrame(gameLoop);
                    }
                    break;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                isThrusting = false;
                isThrustLeft = false;
                isThrustRight = false;
                rocketSound.pause();
            }
            if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                accelerationX = 0;
                isThrusting = false;
                isThrustLeft = false;
                isThrustRight = false;
            }
        });
       
        initializeGame();

    </script>

</body>
</html>
